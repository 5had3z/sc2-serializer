<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Applying to New Dataset &mdash; StarCraft II Serializer  documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=86f27845" />
      <link rel="stylesheet" type="text/css" href="_static/graphviz.css?v=eafc0fe6" />

  
  
        <script src="_static/jquery.js?v=8dae8fb0"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="_static/documentation_options.js?v=5929fcd5"></script>
        <script src="_static/doctools.js?v=888ff710"></script>
        <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="C++ API" href="cpp_api/index.html" />
    <link rel="prev" title="Benchmarks" href="benchmark.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            StarCraft II Serializer
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="index.html">Welcome to sc2-serializer’s documentation!</a></li>
<li class="toctree-l1"><a class="reference internal" href="replay_data.html">Replay Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="dataloading.html">Dataloading</a></li>
<li class="toctree-l1"><a class="reference internal" href="scripts.html">Scripts</a></li>
<li class="toctree-l1"><a class="reference internal" href="benchmark.html">Benchmarks</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Applying to New Dataset</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#serialized-database">Serialized Database</a></li>
<li class="toctree-l2"><a class="reference internal" href="#automatic-struct-to-vector-and-enums">Automatic Struct to Vector and Enums</a></li>
<li class="toctree-l2"><a class="reference internal" href="#struct-of-array-array-of-struct">Struct-of-Array &lt;-&gt; Array-of-Struct</a></li>
<li class="toctree-l2"><a class="reference internal" href="#instance-transform-flattenandsortdata-2">Instance Transform (flattenAndSortData(2))</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="cpp_api/index.html">C++ API</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">StarCraft II Serializer</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Applying to New Dataset</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/custom_dataset.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="applying-to-new-dataset">
<span id="custom-dataset"></span><h1>Applying to New Dataset<a class="headerlink" href="#applying-to-new-dataset" title="Link to this heading"></a></h1>
<p>Much of the code has been written with templates so there are plenty of customization points where you can make simple modifications to fit your needs.</p>
<p>We include an example of a custom project in <code class="docutils literal notranslate"><span class="pre">bin/custom_example.cpp</span></code>. This example demonstrates a scenario where of a set of humans and robots observed in an environment over time, each with varying and random properties. You can run this example <code class="docutils literal notranslate"><span class="pre">./example_custom</span> <span class="pre">--file</span> <span class="pre">test.db</span> <span class="pre">--duration</span> <span class="pre">10</span></code> and see some data printed as the data is generated and written to the database. This entry can be then read-back to the user with <code class="docutils literal notranslate"><span class="pre">./example_custom</span> <span class="pre">--file</span> <span class="pre">test.db</span> <span class="pre">--index</span> <span class="pre">0</span></code> and it should print back the same metadata logs that occurred during generation/writing.</p>
<section id="serialized-database">
<h2>Serialized Database<a class="headerlink" href="#serialized-database" title="Link to this heading"></a></h2>
<p><code class="docutils literal notranslate"><span class="pre">ReplayDatabase</span></code> is templated on a which specializes the <code class="docutils literal notranslate"><span class="pre">DatabaseInterface</span></code> type, hence fulfils the <code class="docutils literal notranslate"><span class="pre">HasDBInterface</span></code> concept. This <code class="docutils literal notranslate"><span class="pre">DatabaseInterface</span></code> defines how to read and write that type to the database, as well as other utilities such as only reading the header to get <code class="docutils literal notranslate"><span class="pre">ReplayInfo</span></code> metadata. The metadata/header is relatively hard-coded into the <code class="docutils literal notranslate"><span class="pre">DatabaseInterface</span></code>, it is up to the user to modify that as appropriate.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;replay_interface.hpp&quot;</span>

<span class="k">namespace</span><span class="w"> </span><span class="nn">cvt</span><span class="w"> </span><span class="p">{</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">MyDatasetEntry</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">ReplayInfo</span><span class="w"> </span><span class="n">header</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="w"> </span><span class="n">timeseriesA</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="w"> </span><span class="n">timeseriesB</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">DatabaseInterface</span><span class="o">&lt;</span><span class="n">MyDatasetEntry</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">getHeaderImpl</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">istream</span><span class="w"> </span><span class="o">&amp;</span><span class="n">dbStream</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">ReplayInfo</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">ReplayInfo</span><span class="w"> </span><span class="n">result</span><span class="p">;</span>
<span class="w">        </span><span class="n">deserialize</span><span class="p">(</span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="n">dbStream</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">result</span><span class="p">;</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="c1">// Implement other methods</span>

<span class="p">};</span>

<span class="p">}</span><span class="w"> </span><span class="c1">// namespace cvt</span>
</pre></div>
</div>
</section>
<section id="automatic-struct-to-vector-and-enums">
<h2>Automatic Struct to Vector and Enums<a class="headerlink" href="#automatic-struct-to-vector-and-enums" title="Link to this heading"></a></h2>
<p>This process is automated for most common datatypes (struct, vector, enum, numeric) and is applied recursively. Enums that need the auto one-hot encoding transform must be added to the chain of <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">constexpr</span></code> in <code class="docutils literal notranslate"><span class="pre">getEnumValues()</span></code> in <code class="docutils literal notranslate"><span class="pre">enums.hpp</span></code>. Then any struct that contains the enum can be vectorized with a one-hot encoding of that enum. Mapping types haven’t been implemented as there hasn’t been a use case for it yet.</p>
</section>
<section id="struct-of-array-array-of-struct">
<h2>Struct-of-Array &lt;-&gt; Array-of-Struct<a class="headerlink" href="#struct-of-array-array-of-struct" title="Link to this heading"></a></h2>
<p>A <strong>Struct-of-Arrays</strong> representation of the target <em>Struct</em> that fulfils the <code class="docutils literal notranslate"><span class="pre">IsSoAType</span></code> concept must be defined with identical names between the members for the automatic <code class="docutils literal notranslate"><span class="pre">AoStoSoA</span></code> and <code class="docutils literal notranslate"><span class="pre">SoAtoAoS</span></code> to function correctly. <code class="docutils literal notranslate"><span class="pre">cvt::gatherStructAtIndex</span></code> can be used when defining <code class="docutils literal notranslate"><span class="pre">operator[]</span></code> in the SoA type to automate gathering data from each of the vectors in the <em>SoA</em>.</p>
<p>A simple example of a struct <code class="docutils literal notranslate"><span class="pre">A</span></code> and its SoA is shown below. This method only applies top level struct, and is not recursive, hence <code class="docutils literal notranslate"><span class="pre">ASoA</span></code> contains <code class="docutils literal notranslate"><span class="pre">std::vector&lt;B&gt;</span></code>. The field names can be out-of-order between <code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">ASoA</span></code>. At compile-time fields are matched by name rather than by index. Hence, there must be a 1-to-1 mapping between field (you should get a compile-time error otherwise). Note, there is no check for identical types between names, only that one is assignable to another.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">B</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">A</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">    </span><span class="n">B</span><span class="w"> </span><span class="n">c</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">ASoA</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="n">struct_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span><span class="w"> </span><span class="n">c</span><span class="p">;</span>

<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="k">operator</span><span class="p">[](</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="w"> </span><span class="n">index</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">noexcept</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">struct_type</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">cvt</span><span class="o">::</span><span class="n">gatherStructAtIndex</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span><span class="w"> </span><span class="n">index</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">noexcept</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Specialized <strong>SoA&lt;-&gt;AoS</strong> transforms can be defined if the automated process isn’t appropriate. For example <code class="docutils literal notranslate"><span class="pre">ReplayData</span></code> and <code class="docutils literal notranslate"><span class="pre">ReplayDataSoA</span></code> is a struct containing a header and the replay data. Hence, we plainly copy the Header data, and perform the transform on the replay observation data (see <code class="docutils literal notranslate"><span class="pre">aos_impl.cpp</span></code>).</p>
</section>
<section id="instance-transform-flattenandsortdata-2">
<h2>Instance Transform (flattenAndSortData(2))<a class="headerlink" href="#instance-transform-flattenandsortdata-2" title="Link to this heading"></a></h2>
<p>The transform that converts the time-major representation of the units to an instance-major <strong>SoA</strong> is <code class="docutils literal notranslate"><span class="pre">flattenAndSortData</span></code> and recovers back to the time-major is <code class="docutils literal notranslate"><span class="pre">recoverFlattenedSortedData</span></code>. The <strong>v2</strong> of these functions (suffixed by 2), further compresses the time indices as [start,count] pairs. This didn’t have a significant impact to final filesize, but the work was done for a more sophisticated algorithm so it might as well be used.</p>
<p>These functions accept any <code class="docutils literal notranslate"><span class="pre">IsSoAType</span></code> and use a user-defined <code class="docutils literal notranslate"><span class="pre">Comp</span></code> function which enables sorting of any underlying <em>struct</em> by any field. This comparison function applies the comparison on a StepIndex and Struct pair, hence using <code class="docutils literal notranslate"><span class="pre">.second</span></code> is needed to access your struct. The code for sorting the SC2 Unit observation data is shown below. The recovery will not return the same order of units in each timestep (the inner std::vector), but they will still be the same set of units in each timestep.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="n">getInstanceSortedUnits</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Unit</span><span class="o">&gt;&gt;&amp;</span><span class="w"> </span><span class="n">units</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Full type in lambda for verbosity, but you are encouraged to use auto...</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">byInstanceId</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[](</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">second</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">b</span><span class="p">.</span><span class="n">second</span><span class="p">.</span><span class="n">id</span><span class="p">;</span>
<span class="w">    </span><span class="p">};</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">cvt</span><span class="o">::</span><span class="n">flattenAndSortData</span><span class="o">&lt;</span><span class="n">cvt</span><span class="o">::</span><span class="n">UnitSoA</span><span class="o">&gt;</span><span class="p">(</span><span class="n">replayData</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">units</span><span class="p">,</span><span class="w"> </span><span class="n">byInstanceId</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="benchmark.html" class="btn btn-neutral float-left" title="Benchmarks" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="cpp_api/index.html" class="btn btn-neutral float-right" title="C++ API" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020, Bryce Ferenczi.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>